/* tslint:disable */
/* eslint-disable */
/**
 * PocketSmith
 * The PocketSmith API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: api@pocketsmith.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base'
// @ts-ignore
import type { BudgetAnalysisPackage } from '../../model'
/**
 * BudgetingApi - axios parameter creator
 * @export
 */
export const BudgetingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Lists the user\'s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @summary List budget for user
     * @param {number} id The unique identifier of the account.
     * @param {boolean} [rollUp] Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBudgetGet: async (
      id: number,
      rollUp?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('usersIdBudgetGet', 'id', id)
      const localVarPath = `/users/{id}/budget`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication developerKey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Developer-Key', configuration)

      if (rollUp !== undefined) {
        localVarQueryParameter['roll_up'] = rollUp
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the user\'s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @summary Get budget summary for user
     * @param {number} id The unique identifier of the user.
     * @param {UsersIdBudgetSummaryGetPeriod} period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it\&#39;s highly unlikely that event period analysis will be possible.
     * @param {number} interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
     * @param {string} startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {string} endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBudgetSummaryGet: async (
      id: number,
      period: UsersIdBudgetSummaryGetPeriod,
      interval: number,
      startDate: string,
      endDate: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('usersIdBudgetSummaryGet', 'id', id)
      // verify required parameter 'period' is not null or undefined
      assertParamExists('usersIdBudgetSummaryGet', 'period', period)
      // verify required parameter 'interval' is not null or undefined
      assertParamExists('usersIdBudgetSummaryGet', 'interval', interval)
      // verify required parameter 'startDate' is not null or undefined
      assertParamExists('usersIdBudgetSummaryGet', 'startDate', startDate)
      // verify required parameter 'endDate' is not null or undefined
      assertParamExists('usersIdBudgetSummaryGet', 'endDate', endDate)
      const localVarPath = `/users/{id}/budget_summary`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication developerKey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Developer-Key', configuration)

      if (period !== undefined) {
        localVarQueryParameter['period'] = period
      }

      if (interval !== undefined) {
        localVarQueryParameter['interval'] = interval
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the user\'s cached forecast by recalculating the forecast.
     * @summary Delete forecast cache for user
     * @param {number} id The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdForecastCacheDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('usersIdForecastCacheDelete', 'id', id)
      const localVarPath = `/users/{id}/forecast_cache`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication developerKey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Developer-Key', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @summary Get trend analysis for user
     * @param {number} id The unique identifier of the user.
     * @param {UsersIdTrendAnalysisGetPeriod} period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it\&#39;s highly unlikely that event period analysis will be possible.
     * @param {number} interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
     * @param {string} startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {string} endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {string} categories A comma-separated list of category IDs to analyse.
     * @param {string} scenarios A comma-separated list of scenario IDs to analyse. You\&#39;re likely going to want to include all a user\&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdTrendAnalysisGet: async (
      id: number,
      period: UsersIdTrendAnalysisGetPeriod,
      interval: number,
      startDate: string,
      endDate: string,
      categories: string,
      scenarios: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'id', id)
      // verify required parameter 'period' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'period', period)
      // verify required parameter 'interval' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'interval', interval)
      // verify required parameter 'startDate' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'startDate', startDate)
      // verify required parameter 'endDate' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'endDate', endDate)
      // verify required parameter 'categories' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'categories', categories)
      // verify required parameter 'scenarios' is not null or undefined
      assertParamExists('usersIdTrendAnalysisGet', 'scenarios', scenarios)
      const localVarPath = `/users/{id}/trend_analysis`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication developerKey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Developer-Key', configuration)

      if (period !== undefined) {
        localVarQueryParameter['period'] = period
      }

      if (interval !== undefined) {
        localVarQueryParameter['interval'] = interval
      }

      if (startDate !== undefined) {
        localVarQueryParameter['start_date'] = startDate
      }

      if (endDate !== undefined) {
        localVarQueryParameter['end_date'] = endDate
      }

      if (categories !== undefined) {
        localVarQueryParameter['categories'] = categories
      }

      if (scenarios !== undefined) {
        localVarQueryParameter['scenarios'] = scenarios
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BudgetingApi - functional programming interface
 * @export
 */
export const BudgetingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BudgetingApiAxiosParamCreator(configuration)
  return {
    /**
     * Lists the user\'s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @summary List budget for user
     * @param {number} id The unique identifier of the account.
     * @param {boolean} [rollUp] Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdBudgetGet(
      id: number,
      rollUp?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BudgetAnalysisPackage>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBudgetGet(id, rollUp, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['BudgetingApi.usersIdBudgetGet']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the user\'s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @summary Get budget summary for user
     * @param {number} id The unique identifier of the user.
     * @param {UsersIdBudgetSummaryGetPeriod} period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it\&#39;s highly unlikely that event period analysis will be possible.
     * @param {number} interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
     * @param {string} startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {string} endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdBudgetSummaryGet(
      id: number,
      period: UsersIdBudgetSummaryGetPeriod,
      interval: number,
      startDate: string,
      endDate: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BudgetAnalysisPackage>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBudgetSummaryGet(
        id,
        period,
        interval,
        startDate,
        endDate,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['BudgetingApi.usersIdBudgetSummaryGet']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete the user\'s cached forecast by recalculating the forecast.
     * @summary Delete forecast cache for user
     * @param {number} id The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdForecastCacheDelete(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdForecastCacheDelete(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['BudgetingApi.usersIdForecastCacheDelete']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @summary Get trend analysis for user
     * @param {number} id The unique identifier of the user.
     * @param {UsersIdTrendAnalysisGetPeriod} period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it\&#39;s highly unlikely that event period analysis will be possible.
     * @param {number} interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
     * @param {string} startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {string} endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {string} categories A comma-separated list of category IDs to analyse.
     * @param {string} scenarios A comma-separated list of scenario IDs to analyse. You\&#39;re likely going to want to include all a user\&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdTrendAnalysisGet(
      id: number,
      period: UsersIdTrendAnalysisGetPeriod,
      interval: number,
      startDate: string,
      endDate: string,
      categories: string,
      scenarios: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BudgetAnalysisPackage>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdTrendAnalysisGet(
        id,
        period,
        interval,
        startDate,
        endDate,
        categories,
        scenarios,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['BudgetingApi.usersIdTrendAnalysisGet']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * BudgetingApi - factory interface
 * @export
 */
export const BudgetingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = BudgetingApiFp(configuration)
  return {
    /**
     * Lists the user\'s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @summary List budget for user
     * @param {BudgetingApiUsersIdBudgetGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBudgetGet(
      requestParameters: BudgetingApiUsersIdBudgetGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<BudgetAnalysisPackage>> {
      return localVarFp
        .usersIdBudgetGet(requestParameters.id, requestParameters.rollUp, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get the user\'s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @summary Get budget summary for user
     * @param {BudgetingApiUsersIdBudgetSummaryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdBudgetSummaryGet(
      requestParameters: BudgetingApiUsersIdBudgetSummaryGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<BudgetAnalysisPackage>> {
      return localVarFp
        .usersIdBudgetSummaryGet(
          requestParameters.id,
          requestParameters.period,
          requestParameters.interval,
          requestParameters.startDate,
          requestParameters.endDate,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete the user\'s cached forecast by recalculating the forecast.
     * @summary Delete forecast cache for user
     * @param {BudgetingApiUsersIdForecastCacheDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdForecastCacheDelete(
      requestParameters: BudgetingApiUsersIdForecastCacheDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .usersIdForecastCacheDelete(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @summary Get trend analysis for user
     * @param {BudgetingApiUsersIdTrendAnalysisGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdTrendAnalysisGet(
      requestParameters: BudgetingApiUsersIdTrendAnalysisGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<BudgetAnalysisPackage>> {
      return localVarFp
        .usersIdTrendAnalysisGet(
          requestParameters.id,
          requestParameters.period,
          requestParameters.interval,
          requestParameters.startDate,
          requestParameters.endDate,
          requestParameters.categories,
          requestParameters.scenarios,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for usersIdBudgetGet operation in BudgetingApi.
 * @export
 * @interface BudgetingApiUsersIdBudgetGetRequest
 */
export interface BudgetingApiUsersIdBudgetGetRequest {
  /**
   * The unique identifier of the account.
   * @type {number}
   * @memberof BudgetingApiUsersIdBudgetGet
   */
  readonly id: number

  /**
   * Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent.
   * @type {boolean}
   * @memberof BudgetingApiUsersIdBudgetGet
   */
  readonly rollUp?: boolean
}

/**
 * Request parameters for usersIdBudgetSummaryGet operation in BudgetingApi.
 * @export
 * @interface BudgetingApiUsersIdBudgetSummaryGetRequest
 */
export interface BudgetingApiUsersIdBudgetSummaryGetRequest {
  /**
   * The unique identifier of the user.
   * @type {number}
   * @memberof BudgetingApiUsersIdBudgetSummaryGet
   */
  readonly id: number

  /**
   * The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it\&#39;s highly unlikely that event period analysis will be possible.
   * @type {'weeks' | 'months' | 'years' | 'event'}
   * @memberof BudgetingApiUsersIdBudgetSummaryGet
   */
  readonly period: UsersIdBudgetSummaryGetPeriod

  /**
   * The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
   * @type {number}
   * @memberof BudgetingApiUsersIdBudgetSummaryGet
   */
  readonly interval: number

  /**
   * The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
   * @type {string}
   * @memberof BudgetingApiUsersIdBudgetSummaryGet
   */
  readonly startDate: string

  /**
   * The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
   * @type {string}
   * @memberof BudgetingApiUsersIdBudgetSummaryGet
   */
  readonly endDate: string
}

/**
 * Request parameters for usersIdForecastCacheDelete operation in BudgetingApi.
 * @export
 * @interface BudgetingApiUsersIdForecastCacheDeleteRequest
 */
export interface BudgetingApiUsersIdForecastCacheDeleteRequest {
  /**
   * The unique identifier of the user.
   * @type {number}
   * @memberof BudgetingApiUsersIdForecastCacheDelete
   */
  readonly id: number
}

/**
 * Request parameters for usersIdTrendAnalysisGet operation in BudgetingApi.
 * @export
 * @interface BudgetingApiUsersIdTrendAnalysisGetRequest
 */
export interface BudgetingApiUsersIdTrendAnalysisGetRequest {
  /**
   * The unique identifier of the user.
   * @type {number}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly id: number

  /**
   * The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it\&#39;s highly unlikely that event period analysis will be possible.
   * @type {'weeks' | 'months' | 'years' | 'event'}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly period: UsersIdTrendAnalysisGetPeriod

  /**
   * The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
   * @type {number}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly interval: number

  /**
   * The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
   * @type {string}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly startDate: string

  /**
   * The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
   * @type {string}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly endDate: string

  /**
   * A comma-separated list of category IDs to analyse.
   * @type {string}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly categories: string

  /**
   * A comma-separated list of scenario IDs to analyse. You\&#39;re likely going to want to include all a user\&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included.
   * @type {string}
   * @memberof BudgetingApiUsersIdTrendAnalysisGet
   */
  readonly scenarios: string
}

/**
 * BudgetingApi - object-oriented interface
 * @export
 * @class BudgetingApi
 * @extends {BaseAPI}
 */
export class BudgetingApi extends BaseAPI {
  /**
   * Lists the user\'s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
   * @summary List budget for user
   * @param {BudgetingApiUsersIdBudgetGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BudgetingApi
   */
  public usersIdBudgetGet(requestParameters: BudgetingApiUsersIdBudgetGetRequest, options?: RawAxiosRequestConfig) {
    return BudgetingApiFp(this.configuration)
      .usersIdBudgetGet(requestParameters.id, requestParameters.rollUp, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the user\'s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
   * @summary Get budget summary for user
   * @param {BudgetingApiUsersIdBudgetSummaryGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BudgetingApi
   */
  public usersIdBudgetSummaryGet(
    requestParameters: BudgetingApiUsersIdBudgetSummaryGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BudgetingApiFp(this.configuration)
      .usersIdBudgetSummaryGet(
        requestParameters.id,
        requestParameters.period,
        requestParameters.interval,
        requestParameters.startDate,
        requestParameters.endDate,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the user\'s cached forecast by recalculating the forecast.
   * @summary Delete forecast cache for user
   * @param {BudgetingApiUsersIdForecastCacheDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BudgetingApi
   */
  public usersIdForecastCacheDelete(
    requestParameters: BudgetingApiUsersIdForecastCacheDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BudgetingApiFp(this.configuration)
      .usersIdForecastCacheDelete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
   * @summary Get trend analysis for user
   * @param {BudgetingApiUsersIdTrendAnalysisGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BudgetingApi
   */
  public usersIdTrendAnalysisGet(
    requestParameters: BudgetingApiUsersIdTrendAnalysisGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return BudgetingApiFp(this.configuration)
      .usersIdTrendAnalysisGet(
        requestParameters.id,
        requestParameters.period,
        requestParameters.interval,
        requestParameters.startDate,
        requestParameters.endDate,
        requestParameters.categories,
        requestParameters.scenarios,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const UsersIdBudgetSummaryGetPeriod = {
  Weeks: 'weeks',
  Months: 'months',
  Years: 'years',
  Event: 'event',
} as const
export type UsersIdBudgetSummaryGetPeriod =
  (typeof UsersIdBudgetSummaryGetPeriod)[keyof typeof UsersIdBudgetSummaryGetPeriod]
/**
 * @export
 */
export const UsersIdTrendAnalysisGetPeriod = {
  Weeks: 'weeks',
  Months: 'months',
  Years: 'years',
  Event: 'event',
} as const
export type UsersIdTrendAnalysisGetPeriod =
  (typeof UsersIdTrendAnalysisGetPeriod)[keyof typeof UsersIdTrendAnalysisGetPeriod]
